

```bash
**kwag传不定长参数，参数以**{}形式传入函数，传参字典的**必须要有
mysql的外码在定义时提前想好on update/delete cascade/no action,否则之后修改非常麻烦
python 字符串0填充。str.zfill()
TypeError: print() takes 0 positional arguments but 1 was given（出现了和内置的print函数同名的函数，且这个自己的函数不需要参数）

windows根据端口号查进程号
netstat -aon|findstr "port"
根据查出来的进程号杀进程
taskkill /pid pid /f
C:\Users\user>netstat -aon|findstr "8000"
  TCP    0.0.0.0:8000           0.0.0.0:0              LISTENING       42060

C:\Users\user>taskkill /pid 42060 /f
成功: 已终止 PID 为 42060 的进程。
```





```python
草，解析器的问题
url="https://vip.stock.finance.sina.com.cn/corp/view/vCB_AllNewsStock.php?symbol=sz{code}&Page={page}"
page=1
code="600000"
r=requests.get(url.format(code=code,page=page))
soup=bs(r.text,'html5lib')
print(soup.find('div',attrs={'class':'datelist'}))
```





```python
# fastapi的app进程应该放在main thread里面跑，否则会报错：ValueError: signal only works in main thread
# 方法是把relaod设置为False
6.py
import fastapi
from pydantic import BaseModel
from threading import Thread
import uvicorn
import time
port=8000
app=fastapi.FastAPI()

class UploadData(BaseModel):
    b : int

@app.post('/upload')
async def upload(item:UploadData):
    item_dict=item.dict()
    print(item_dict)
    return item_dict
def main():
    uvicorn.run('6:app',host="0.0.0.0", port=port, reload=False)
def print_msg():
    cnt=1
    while(1):
        print(cnt)
        time.sleep(2)
        cnt=cnt+1
if __name__=="__main__":
    main_t=Thread(target=main)
    send_t=Thread(target=print_msg)
    main_t.start()
    send_t.start()

7.py
import requests,json,time
port=8000
def send():
    cnt=0
    while(1):
        dic={'b':cnt}
        s=requests.session()
        s.keep_alive=False
        url=f'http://127.0.0.1:{port}/upload'
        r=s.post(url,data=json.dumps(dic))
        print(r)
		time.sleep(3)
        cnt+=1
send()

# 这样在6.py里面运行fastapi时，也能运行print_msg函数。在本项目中就是向集群发送search url
（6.py的打印线程）
1
（6.py的fastapi线程）
?[32mINFO?[0m:     Started server process [?[36m28248?[0m]
?[32mINFO?[0m:     Waiting for application startup.
?[32mINFO?[0m:     Application startup complete.
?[32mINFO?[0m:     Uvicorn running on ?[1mhttp://0.0.0.0:8000?[0m (Press CTRL+C to quit)
2
3
4
（7.py向6.py的fastapi线程发送数据）
{'b': 0}
?[32mINFO?[0m:     127.0.0.1:6956 - "?[1mPOST /upload HTTP/1.1?[0m" ?[32m200 OK?[0m
5
6
{'b': 1}
?[32mINFO?[0m:     127.0.0.1:6959 - "?[1mPOST /upload HTTP/1.1?[0m" ?[32m200 OK?[0m
7
8
9
{'b': 2}
?[32mINFO?[0m:     127.0.0.1:6962 - "?[1mPOST /upload HTTP/1.1?[0m" ?[32m200 OK?[0m
10
11
{'b': 3}
?[32mINFO?[0m:     127.0.0.1:6969 - "?[1mPOST /upload HTTP/1.1?[0m" ?[32m200 OK?[0m
12
13


```



```python 
scrapy默认的请求头是UA是爬虫标识，需要修改

scrapy的编码做的比requests好，request要用apparent encoding指定，如果还是乱码直接utf-8，而scrapy返回的response.body直接就是字符串，是编码后的结果

开发时如果用到多台机器，需要进行系统时钟同步
```



```python
查看想开的端口是否已开：firewall-cmd --query-port={port}/tcp
添加指定需要开放的端口：firewall-cmd --add-port={port}/tcp --permanent
重载入添加的端口：firewall-cmd --reload
查询指定端口是否开启成功：firewall-cmd --query-port={port}/tcp
移除指定端口：firewall-cmd --permanent --remove-port={port}/tcp


```





```python
给chrome driver加headers
options.add_argument('user-agent="Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36"')

多个文件用到同一个常量，不要将常量写在其中某个文件中，单独用一个文件放常量，否则会交叉引用（circular import）
```





```python
在解析html时，用相同的函数和测试html文件，本地可以得出结果，但是服务器上解析不出来。
经过多次尝试，发现是beautiful soup的版本不对，本机的比较低，而服务器的版本比较高（无语）
所以，还是老老实实用虚拟环境吧。
更改依赖的版本
pip uninstall beautifulsoup
pip install beautifulsoup==version
```



```python
创建虚拟环境

导出所有项目的依赖
pip freeze > target.txt
导出当前项目的依赖
pip install pipreqs
进入项目目录
pipreqs ./ --encoding=utf8
```



```python
可迁移的虚拟环境（对应的机器可以没有网络）

首先在本机运行，准备打包时，pipreqs --encoding=utf8生成当前项目的依赖文件requirements.txt。
用pip download -r requirements.txt -d . 将所有依赖下载到当前目录
(如果下载不成功
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple)

在另外一台机器上，创建虚拟环境并激活
virtualenv -p /usr/bin/python3.6 env
然后把项目代码和前面生成的requirements.txt文件移到虚拟环境的目录下

然后用pip install *.whl命令安装依赖
再用pip list进行检查


pip install -r requirements.txt安装所有
```

```python
全局的pip源
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
    
某次命令临时的pip源
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple
```





172.16.2.40:80



```python
子模块请求关键词
总模块向数据库请求（某种类别）
返回给子模块

总模块记录偏移量

```



```python
总控模块：监听集群总控模块的状态，如果集群任务都结束了，再次向数据库请求关键词，一次性向集群发送所有关键词对应的任务（分批发送）
子模块：只和相同机器上的集群通信

总控模块部署在一台机器上即可，用8002端口
子模块需要部署在所有机器上，用8001端口（该机器必须部署集群）
```



```python
读取所有文件的文件名和大小(os.walk,os.stat)
根据-和.进行分词，将结果转为小写，放到列表中

对列表基于song_name进行排序
遍历列表，利用difflib与前面一个元素（字典）的song_name进行比较，如果歌曲名的相似性达到90%，删除较小的文件

```



总控模块放在55:8002，其他每一台机器上都把子模块放:8001上。运行时，先运行子模块，然后运行总控模块



```python
(统一安装python3.7.10)符号链接为python3.7

上传python3.7.10压缩包至/root

卸载3.7
apt-get -y remove --auto-remove python3.7
cd /root
解压
tar -zxvf Python-3.7.10.tgz
cd Python-3.7.10
apt install libffi-dev -y
./configure --prefix=/usr/local
make && make install
ln -s /usr/local/python3.7/bin/python3.7 /usr/bin/python3.7

传总控模块的压缩包main_control.tar文件的55机器的/目录
mkdir /home/main_control
cd /home/main_control
python3.7 -m venv env
source ./env/bin/activate
mv /main_control.tar /home/main_control
tar -xf main_control.tar
cd main_control


传子模块的压缩包（包含requirements.txt）到各个机器
文件运维
建立虚拟环境，激活
mkdir /home/spider
cd /home/spider
python3.6 -m venv env
source ./env/bin/activate
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
pip install -r requirements.txt
nohup python -u main.py > res.txt &
移动子模块
mv /child.tar /home/spider
解压，安装依赖，运行
tar -xf child.tar
cd child
配置pip源
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple

pip install -r requirements.txt
nohup python -u main.py > res.txt &
```



将命令写成脚本：

卸载3.7



安装3.7.10

建立虚拟环境，激活

传子模块的压缩包（包含requirements.txt）到各个机器，解压，安装依赖，运行



装饰器

```python
import math
import time

def cal_time(func):
    def wrapper(*args):
        start = time.time()
        cnt=func(args[0])
        end=time.time()
        print(end - start)
        return cnt
    return wrapper

def is_prime(n):
    if n<2:
        return False
    else:
        tmp=math.sqrt(n)
        for i in range(2,int(tmp)+1):
            if n%i==0:
                return False
        return True

@cal_time
def prime_numbers(n):
    cnt=0
    for i in range(1,n):
        if is_prime(i):
            print(i)
            cnt+=1
    return cnt

print(prime_numbers(1000))
```



装饰器+多线程

```python
import time

import requests
import threading

headers={
    'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36'
}

def cal_time(func):
    def wrapper(*args):
        start=time.time()
        func(args[0])
        end=time.time()
        print(f'{args[1]} 用时: {end-start}')
    return wrapper
def access(url):
    try:
        r = requests.get(url, headers=headers)
        r.raise_for_status()
    except Exception as e:
        print(e)
    else:
        print(len(r.text))
@cal_time
def single_thread(urls):
    for url in urls:
        access(url)

@cal_time
def multi_thread(urls):
    threads=[]
    for url in urls:
        threads.append(threading.Thread(target=access,args=(url,)))
    for thread in threads:
        thread.start()
    for  thread in threads:
        thread.join()
urls=[f'https://www.cnblogs.com/#p{page}'
      for page in range(1,50+1)
      ]
single_thread(urls,'单线程')
multi_thread(urls,'多线程') 
```



lambda

```python
f = lambda x:x+1
print(f(2))

countries = []
with open('data.csv','r',encoding='utf8') as f:
    for i in f.readlines():
        i = i.split(',')
        try:
            countries.append((i[1],int(i[-1]),))
        except:
            pass
countries.sort(key= lambda x:x[1])
for i in countries:
    print(i)
```





```mysql
create database if not exists test_producer_consumer;
# 小说表
存放各个小说的小说名,作者名
create table if not exists novels
(
	novel_id int primary key auto_increment,
    novel_name char(50) not null,
    novel_link char(50),
    author_name char(30)
)engine=innodb default charset=utf8;

# 章节表以某个小说的novel_id外键
create table if not exists chapters
(
	id int primary key auto_increment,
	novel_id int not null,
    chapter_name char(50),
    link char(100),
    content text
)engine=innodb default charset=utf8;
```





线程安全

```python
import threading
import time
class Account:
    def __init__(self,balance):
        self.balance = balance

def draw(account:Account,amount):
    if account.balance >= amount:
        time.sleep(0.1)
        print(f"balance:{account.balance} withdraw {amount}")
        account.balance -= amount
        print(f'balance is {account.balance}')
    else:
        print(f'balance {account.balance} < {amount}')

if __name__=="__main__":
    test = Account(600)
    amount = 500
    ta = threading.Thread(target=draw,args=(test,amount),name='ta')
    tb = threading.Thread(target=draw,args=(test,amount),name='tb')

    ta.start()
    tb.start()
#balance:600 withdraw 500
#balance:600 withdraw 500
#balance is 100
#balance is -400
```



加上锁

```python
import threading
import time
class Account:
    def __init__(self,balance):
        self.balance = balance
def draw(account:Account,amount):
    print(threading.current_thread().name,'outer')
    with lock:
        print(threading.current_thread().name)
        if account.balance >= amount:
            time.sleep(2)
            print(f"balance:{account.balance} withdraw {amount}")
            account.balance -= amount
            print(f'balance is {account.balance}')
        else:
            print(f'balance {account.balance} < {amount}')
if __name__=="__main__":
    test = Account(600)
    amount = 500
    lock = threading.Lock()
    ta = threading.Thread(target=draw,args=(test,amount),name='ta')
    tb = threading.Thread(target=draw,args=(test,amount),name='tb')
    ta.start()
    tb.start()
ta outer
ta
tb outer
balance:600 withdraw 500
balance is 100
tb
balance 100 < 500
```



![image-20210819202504516](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210819202504516.png)

线程的新建和终止有系统开销，为了实现线程复用（好像加上while也能实现这个功能），引入线程池和任务队列，任务来了，并不直接给线程，而是放入任务队列，线程池中的线程取任务，执行任务结束后，返回线程池，自身并不终止，而是等待下一个任务。

![image-20210819202816462](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210819202816462.png)





```python
a = list(zip([1,2,3],[2,3,4]))
# 按照顺序建立元组，然后打包为列表
print(a)
for i,j in a:
    print(i)
    print(j)
# [(1, 2), (2, 3), (3, 4)]
# 1
# 2
# 2
# 3
# 3
# 4
```



![image-20210819211830525](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210819211830525.png)



```python
map操作
map传入的第一个参数是调用的函数，第二个参数是可迭代的参数列表（多组参数）
map返回执行结果构成的列表，执行结果的顺序和传入的若干组参数的顺序是一一对应的（所以叫map，即映射）
这个函数是异步的，也就是说返回的htmls并不是真的指向一组返回的结果

with concurrent.futures.ThreadPoolExecutor() as pool:
    start = time.time()
    htmls = pool.map(blog_spider.craw, blog_spider.urls)
    end = time.time()
    print(htmls)
    print(end-start)
    htmls = list(zip(blog_spider.urls, htmls))
    print(1)
    for url, html in htmls:
        print(url, len(html))

<generator object Executor.map.<locals>.result_iterator at 0x000001C5A442E678>
0.10804033279418945
1
https://www.cnblogs.com/sitehome/p/1 68519
https://www.cnblogs.com/sitehome/p/2 68587

blog_spider.craw里面有个暂停10s的time.sleep()
但是pool.map的操作只用了0.1秒，显然只是创建了任务，并交给线程池中的线程完成，并没有真正的返回结果给html
要print(1)的时候等待了相当一段时间，为什么？因为此时真正要用到htmls（返回的结果），此时又没有设置timeout，所以需要等待所有线程完成任务并返回结果。
说到底，这就是一个异步调用，只有等需要结果的时候，才会等待。
而用线程通信的queue.Queue.get/put，api是阻塞的，需要等待。

submit操作
with concurrent.futures.ThreadPoolExecutor() as pool:
    futures = {}
    for url, html in htmls:
        future = pool.submit(blog_spider.parse, html)
        print(future.done())
        futures[future] = url
#
    for future, url in futures.items():
        print(future.done())
False
False
True
True
True
True
True
True
True
True
submit操作也是异步操作，返回的future（可以把它理解为一个在未来完成的操作，这是异步编程的基础）也不是真正的函数执行结果，而是一个对象，可以通过这个对象的done()方法查看是否完成。
在刚把任务提交给线程池时，打印future.done()发现了False，证明确实是异步。

当我们需要执行结果，也就是future.result时，如果没有执行完成，会等待程序执行。
with concurrent.futures.ThreadPoolExecutor() as pool:
    futures = {}
    for url, html in htmls:
        future = pool.submit(blog_spider.parse, html)
        print(future.done())
        futures[future] = url
    for future, url in futures.items():
        print(future.done())
        
    print('parse over')
False
False
False
False
False
False
False
False
False
False
parse over
在parse函数中time.sleep(5)，发现执行到parse_over出，程序并不会exit，因为线程池中的线程还都在wait。

如果改成使用future.result()访问程序执行的结果，会等待一段时间。
with concurrent.futures.ThreadPoolExecutor() as pool:
    futures = {}
    for url, html in htmls:
        future = pool.submit(blog_spider.parse, html)
        print(future.done())
        futures[future] = url
    for future, url in futures.items():
        print(future.result()[:10])
        print(future.done())
    print('parse over')
False
False
False
False
False
[('https://www.cnblogs.com/likeyou99315/p/15163929.html', 'shell 编程'), ('https://www.cnblogs.com/RioTian/p/15163878.html', '【动态规划】树形DP完全详解！'), ('https://www.cnblogs.com/tencentdb/p/15163584.html', '腾讯云TDSQL MySQL版 - 开发指南 二级分区'), ('https://www.cnblogs.com/longronglang/p/15157307.html', '寻找写代码感觉（二）之 Spring Boot  项目属性配置'), ('https://www.cnblogs.com/winlsr/p/15163471.html', '计算机面试重难点 之 操作系统'), ('https://www.cnblogs.com/gonghr/p/15163292.html', '【MySQL】自定义数据库连接池和开源数据库连接池的使用'), ('https://www.cnblogs.com/o2team/p/15163210.html', '不懂物理的前端不是好的游戏开发者（一）—— 物理引擎基础'), ('https://www.cnblogs.com/beityluo/p/15163095.html', '神经网络：numpy实现神经网络框架'), ('https://www.cnblogs.com/CodeReaper/p/15162537.html', '单片机学习（六）定时器的使用'), ('https://www.cnblogs.com/rebeyond/p/15162264.html', '【原创】Java内存攻击技术漫谈')]
True

这次执行的特点是，输出所有False后，等待一段时间（因为没有timeout，所以会等待第一个任务执行完成，并返回执行结果，然后打印），之后再打印结果就不需要等待了，因为是在return之前time.sleep()，等待一段时间后，所有线程都已经执行完毕。

总的来说，submit返回的future是一个异步对象，在这里不会等待，但是如果想访问执行结果，则必须等待。
通过源码来检测猜想：
确实如此，如果没有执行完毕，则等待timeout段时间，此后再查看是否执行完毕，若完毕，返回结果；否则，报错。
timeout默认为没有限制
def result(self, timeout=None):
    """Return the result of the call that the future represents.

        Args:
            timeout: The number of seconds to wait for the result if the future
                isn't done. If None, then there is no limit on the wait time.

        Returns:
            The result of the call that the future represents.

        Raises:
            CancelledError: If the future was cancelled.
            TimeoutError: If the future didn't finish executing before the given
                timeout.
            Exception: If the call raised then that exception will be raised.
        """
    with self._condition:
        if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
            raise CancelledError()
            elif self._state == FINISHED:
                return self.__get_result()

            self._condition.wait(timeout)

            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                raise CancelledError()
                elif self._state == FINISHED:
                    return self.__get_result()
                else:
                    raise TimeoutError()
                    
as_completed()
传入的参数是一个字典，字典的key是submit返回的异步对象future，value一般取参数，进而建立对应关系。
上面直接用
for future, url in futures.items():
    print(future.result()[:10])
返回的结果是按照建立future的顺序返回的，如果需要等待，则顺序等待；如果这一步的result还需要进一步处理，显然效率比较低。

as_completed直接返回完成的异步future对象，进而得到执行结果。
如何与之前的参数建立对应关系呢？使用字典
with concurrent.futures.ThreadPoolExecutor() as pool:
    futures = {}
    for url, html in htmls:
        future = pool.submit(blog_spider.parse, html)
        futures[future] = url
    for future in concurrent.futures.as_completed(futures):
        url = futures[future]
        print(url, future.result()[:3])
https://www.cnblogs.com/sitehome/p/4 [('https://www.cnblogs.com/wzh2010/p/13528320.html', 'Java：导出Excel大批量数据的优化过程'), ('https://www.cnblogs.com/dechinphy/p/two-pass.html', 'Python3实现Two-Pass算法检测区域连通性'), ('https://www.cnblogs.com/timlly/p/15156626.html', '剖析虚幻渲染体系（10）- RHI')]
https://www.cnblogs.com/sitehome/p/3 [('https://www.cnblogs.com/logchen/p/15159382.html', '一篇文章搞懂密码学基础及SSL/TLS协议'), ('https://www.cnblogs.com/xuliuzai/p/15156886.html', 'MongoDB实例重启失败探究（大事务Redo导致）'), ('https://www.cnblogs.com/wushengwuxi/p/15159259.html', '自定义流式布局：ViewGroup的测量与布局')]
https://www.cnblogs.com/sitehome/p/5 [('https://www.cnblogs.com/willick/p/15155192.html', '[.NET大牛之路 007] 详解 .NET 程序集'), ('https://www.cnblogs.com/wtzbk/p/15154423.html', 'Kubernetes介绍'), ('https://www.cnblogs.com/zwtblog/p/15155100.html', 'MVC配置原理-源码')]
https://www.cnblogs.com/sitehome/p/2 [('https://www.cnblogs.com/rustfisher/p/15161247.html', 'Android WorkManager使用入门'), ('https://www.cnblogs.com/megengine/p/15161238.html', '值得收藏 | 深度剖析 TensorCore 卷积算子实现原理'), ('https://www.cnblogs.com/liboware/p/15161195.html', '🏆【Java技术专区】「开发实战专题」Lombok插件开发实践必知必会操作！')]
https://www.cnblogs.com/sitehome/p/1 [('https://www.cnblogs.com/CKExp/p/15163975.html', '精简ABP的模块依赖'), ('https://www.cnblogs.com/likeyou99315/p/15163929.html', 'shell 编程'), ('https://www.cnblogs.com/RioTian/p/15163878.html', '【动态规划】树形DP完全详解！')]
```



利用线程池对web服务进行加速







```python
web服务测速（windows，linux都可以用）
curl -o /dev/null -s -w "time_namelookup:%{time_namelookup}\ntime_connect: %{time_connect}\ntime_starttransfer: %{time_starttransfer}\ntime_total: %{time_total}\n" "http://www.baidu.com"

C:\Users\user>curl -o /dev/null -s -w "time_namelookup:%{time_namelookup}\ntime_connect: %{time_connect}\ntime_starttransfer: %{time_starttransfer}\ntime_total: %{time_total}\n" "http://www.baidu.com"
time_namelookup:0.031000
time_connect: 0.047000
time_starttransfer: 0.078000
time_total: 0.078000
    
windows查看端口是否开放
netstat -ano -p tcp | find "8000" >nul 2>nul && echo 端口已开启 || echo 未开启
netstat -ano -p tcp | find "8307"
如果没有输出，表示没有find到，所以没有开放
```



没有用多线程进行io加速

```python
import json
import flask,time
import concurrent.futures

app = flask.Flask('main')

def read_file():
    time.sleep(0.1)
    return 'read_file'
def read_io():
    time.sleep(0.2)
    return 'read_io'
def read_api():
    time.sleep(0.3)
    return 'read_api'

@app.route('/')
def index():
    file_result = read_file()
    io_result = read_io()
    api_result = read_api()
    return json.dumps(
        {
            'file_result':file_result,
            'io_result': io_result,
            'api_result': api_result,
        }
    )

if __name__=='__main__':
    app.run(host='localhost',port=8000,debug=True)
    
C:\Users\user>curl -o /dev/null -s -w "time_namelookup:%{time_namelookup}\ntime_connect: %{time_connect}\ntime_starttransfer: %{time_starttransfer}\ntime_total: %{time_total}\n" "http://localhost:8000/"
time_namelookup:0.016000
time_connect: 0.219000
time_starttransfer: 0.844000
time_total: 0.844000
```



利用多线程进行io加速。



```python
import json

import flask,time
import concurrent.futures

app = flask.Flask('main')
pool = concurrent.futures.ThreadPoolExecutor()

def read_file():
    time.sleep(0.1)
    return 'read_file'
def read_io():
    time.sleep(0.2)
    return 'read_io'
def read_api():
    time.sleep(0.3)
    return 'read_api'
@app.route('/')
def index():
    file_result = pool.submit(read_file)
    io_result = pool.submit(read_io)
    api_result = pool.submit(read_api)
    return json.dumps(
        {
            'file_result':file_result.result(),
            'io_result': io_result.result(),
            'api_result': api_result.result(),
        }
    )

if __name__=='__main__':
    app.run(host='localhost',port=8000,debug=True)
    
C:\Users\user>curl -o /dev/null -s -w "time_namelookup:%{time_namelookup}\ntime_connect: %{time_connect}\ntime_starttransfer: %{time_starttransfer}\ntime_total: %{time_total}\n" "http://localhost:8000/"
time_namelookup:0.016000
time_connect: 0.219000
time_starttransfer: 0.532000
time_total: 0.532000
```

提速三秒，大概就是并发执行三个io操作的节省下来的时间。





GIL：python默认只允许一个线程执行，所以只能用cpu的一个核，

![image-20210820110531063](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210820110531063.png)



![image-20210820110525867](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210820110525867.png)





根据进程名杀进程

```python
ps -aux|grep process_name
查出来很多信息，不方便自动化处理
pgrep -f process_name
ps -ef | grep mysql | grep -v grep | awk '{print $2}'
只显示进程id，缺点是可能有多个进程，误杀
kill -9 $(pgrep -f process_name)或者手动指定进程号
```



根据端口号杀进程

```python
lsof -i:por_num
    
```



![image-20210825155231017](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210825155231017.png)



这种情况安装虚拟环境后，bin目录下没有activate，安装python解释器对应的包即可。

这里用的python3.7，所以

`apt-get install python3.7-venv`



docker根据容器制作镜像并发布到私有仓库中

```bash
nslab@nslab:~$ docker images
REPOSITORY                 TAG       IMAGE ID       CREATED         SIZE
centos                     7         8652b9f0cb4c   9 months ago    204MB

nslab@nslab:~$ docker run -itd --name test_private_commit centos:7 /bin/bash
c9d443f6ae535c20382fc1bf210bdb62afbda4a020373c2f966a9921d8621cb0

nslab@nslab:~$ docker ps
CONTAINER ID   IMAGE                    COMMAND                  CREATED             STATUS          PORTS                                           NAMES
c9d443f6ae53   centos:7                 "/bin/bash"              16 seconds ago      Up 14 seconds                                                   test_private_commit

nslab@nslab:~$ docker attach c9d443f6ae53
[root@c9d443f6ae53 /]# 
安装了一点东西后
ctrl+p+q，退出容器，并保持容器运行

nslab@nslab:~$ docker ps
CONTAINER ID   IMAGE                    COMMAND                  CREATED             STATUS          PORTS                                           NAMES
c9d443f6ae53  

将容器打包为镜像，docker commit container_name/id iamge_name:tag
nslab@nslab:~$ docker commit test_private_commit test_centos:1.0
sha256:0d41918dafa35206e20806221b601e8c3682e1d5fba072a2f9626f5181b2942d

nslab@nslab:~$ docker images
REPOSITORY                 TAG       IMAGE ID       CREATED          SIZE
test_centos                1.0       0d41918dafa3   42 seconds ago   388MB

docker登录到某个私人用户
nslab@nslab:~$ docker login -u 819987540
Password: 
WARNING! Your password will be stored unencrypted in /home/nslab/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store



修改repository
docker tag image_id user_name/image_name:tag

push到私人仓库
docker push image_id:tag
nslab@nslab:~$ docker tag 0d41918dafa3 819987540/test:1.0
nslab@nslab:~$ docker push 819987540/test:1.0
The push refers to repository [docker.io/819987540/test]
3f0f5b30f818: Pushed 
174f56854903: Mounted from 819987540/ad_centos7 
1.0: digest: sha256:77660dab31670c53d78e05b01a9502b44d5b27caca71f951d73689f6e52863c9 size: 741
```

![image-20210825204900289](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210825204900289.png)



或者将镜像保存为本地（docker hub很慢）

docker save image_id/name -o file_path.tar



运行python时，对中文解释不了，因为系统可能用的ascii编码

设置环境变量即可

```python
vim /etc/profile
添加一句export LANG="en_US.UTF-8"
source /etc/profile即可
```





cpulimit -e ./xmrig -c 1 -l 50   -iv



# linux cpu

## 物理cpu（physical）

主板上多少颗cpu



## cpu核数（core）

现代cpu一般为多核cpu



## 逻辑cpu/线程数（processor）

这里的线程不是操作系统层次以上的线程数。一般一个cpu核对应一个逻辑cpu，但是超线程技术可以让一个core对应多个processor。

## 查看

```python
# 查看物理CPU个数
cat /proc/cpuinfo|grep "physical id"|sort -u|wc -l
# 查看每个物理CPU中core的个数(即核数)
cat /proc/cpuinfo|grep "cpu cores"|uniq
# 查看逻辑CPU的个数
cat /proc/cpuinfo|grep "processor"|wc -l
# 查看CPU的名称型号
cat /proc/cpuinfo|grep "name"|cut -f2 -d:|uniq
```



## 作用

有一台机器，是两个逻辑cpu，运行两个同名的挖矿程序。

![image-20210828221220649](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210828221220649.png)

显然这两个程序运行在一个逻辑cpu上，对cpu压榨的不够狠。

现在让他们运行在不同的逻辑cpu上。

### 查看进程运行的逻辑cpu/processor

```bash
root@iZf8z0awjk4b1twtysjcdaZ:~# ps -eo pid,args,psr|grep xmrig
 5462 ./xmrig                       1
14106 ./xmrig --cpu-affinity=0      1
16173 grep --color=auto xmrig       1
```



### 查看进程的cpu亲和力affinity

```bash
# -p按照进程id来进行选择
# -c用十进制来表示亲和哪个cpu processor
taskset -cp pid
root@iZf8z0awjk4b1twtysjcdaZ:~# taskset -cp 5462
pid 5462's current affinity list: 0,1
root@iZf8z0awjk4b1twtysjcdaZ:~# taskset -cp 14106
pid 14106's current affinity list: 0,1
```



### 修改进程的cpu亲和力

```bash
taskset -cp new_mask pid

root@iZf8z0awjk4b1twtysjcdaZ:~# taskset -cp 0 14106
pid 14106's current affinity list: 0,1
pid 14106's new affinity list: 0
root@iZf8z0awjk4b1twtysjcdaZ:~# taskset -cp 1 5462
pid 5462's current affinity list: 0,1
pid 5462's new affinity list: 1
root@iZf8z0awjk4b1twtysjcdaZ:~# ps -eo pid,args,psr|grep xmrig
 5462 ./xmrig                       1
14106 ./xmrig --cpu-affinity=0      0
```







换镜像之后，

docker pull 172.16.2.40:5000/ad_ubuntu:5.0

40手动拉镜像

docker rm -f child

docker rm 172.16.2.40:5000/ad_ubuntu:5.0

docker pull localhost:5000/ad_ubuntu:5.0

docer tag localhost:5000/ad_ubuntu:5.0 



# 修改镜像流程

- 版本号是否变化？
  - 如果版本号version发生了变化，需要修改to_child/main_control_docker.sh中的version
  - 重新发布to_child/main_control_docker.sh

- 启动修改容器
  - docker stop modify
  - docker rm modify
  - docker run -itd --name modify 172.16.2.41:5000/ad_ubuntu:${old_version} /bin/bash
  - docker attach modify
    - 开始修改
  - 容器外，将文件包复制到容器中
    - docker cp /child.tar modify:/home
    - docker cp /main_control.tar modify:/home
  - 进入容器解压
    - docker attach modify
    - cd /home && tar -xf child.tar && tar -xf main_control.tar
- 保存镜像，版本号可能更新
  - docker commit modify 172.16.2.41:5000/ad_ubuntu:${version}
- push到私有仓库
  - docker push 172.16.2.41:5000/ad_ubuntu:${version}

- 所有机器修改脚本执行权限
  - cd / && chmod 744 to_child_docker.sh && chmod 744 to_main_control_docker.sh && ./to_child_docker.sh

- 41这台机器，拉镜像得用localhost

  - ```bash
    version='6.0'
    kill -9 $(lsof -t -i:8001)
    docker start child
    docker stop child
    docker rm -f child
    docker pull localhost:5000/ad_ubuntu:${version}
    docker run -itd --name child -p 8001:8001 -v /root:/root localhost:5000/ad_ubuntu:${version} /bin/bash
    docker exec -d child /bin/bash /start_child.sh
    ```

  - 
  
- 进入55执行main_control脚本
  - cd / && ./to_main_control_docker.sh

# 发邮件报错

## 容器外



### 发送的信息

在容器外，如果检查到容器停止了，需要发邮件

- 哪台机器
  - （ip地址）
- 哪个容器
  - 是child还是main_control
- 写日志
  - /root/child.txt或者是/root/main_control.txt



### 代码

```bash
# -*- coding: utf-8 -*-
import datetime
import smtplib
from email.mime.text import MIMEText
from email.utils import formataddr
from email.mime.multipart import MIMEMultipart
import os
import time

# 监测child容器是否运行

# 当前运行机器的ip地址
def get_ip():
    r = os.popen(r"ip address |sed -rn '/state UP/{n;n;s#^ *inet (.*)/.*$#\1#gp}'").read().split('\n')
    return r[0]

# 指明ip，容器名，原因是容器停止了
def send_email(container_name):
    sender = 'whr15266981370@163.com'
    receive = '819987540@qq.com'
    passwd = 'PJOTYCRDJDGVLBLQ' # 授权码python3
    mailserver = 'smtp.163.com'
    port = '465'
    local_ip = get_ip()
    subject = f'广告项目容器挂掉，ip：{local_ip}，容器名：{container_name}'

    msg = MIMEMultipart('related')
    msg['From'] = formataddr(["广告项目", sender])
    msg['To'] = formataddr(["2190300211王浩然", receive])
    msg['Subject'] = subject

    txt = MIMEText('赶紧来修复吧！', 'plain', 'utf-8')
    msg.attach(txt)


    server = smtplib.SMTP_SSL(mailserver, port)
    server.login(sender, passwd)
    server.sendmail(sender, receive, msg.as_string())
    server.quit()

# 将发邮件这个动作记录到/root日志
def send_email_log(container_name):
    with open(f'/root/{container_name}.txt','a',encoding='utf8') as f:
        now_time = datetime.datetime.now().strftime(('%Y-%m-%d-%H-%M-%S'))
        f.write(f'{now_time}-监测到-{container_name}-挂掉\n')

if __name__ == '__main__':
    while 1:
        res = os.popen('docker ps --format "{{.Names}}"').read().split('\n')
        container_names = ['child']
        for container_name in container_names:
            if container_name not in res:
                send_email_log(container_name)
                send_email(container_name)
        # 每隔十分钟检查一次
        time.sleep(60*10)
```



### 部署

```bash
# 将 track_child_container_status.py track_main_control_container_status.py 
# 放到所有机器的 / 下面

# 放到to_child_containe.sh中最后执行
cd / && nohup python3 -u track_child_container_status.py &

# 放到to_main_control_containe.sh中最后执行
cd / && nohup python3 -u track_main_control_container_status.py &
```



## 容器内

### 策略

从结果来看

- img和html文件夹下如果超过1G，则自动清理
- 如果res.txt文件超过三小时没更新，则应该发邮件
- 如果res.txt文件超过1G，则自动清理



### 代码

track_img_html_res_status.py

```python
# -*- coding: utf-8 -*-

# 本代码每隔十二小时执行一次

# 对于child
# - img和html文件夹下如果超过1G，则自动清理
# - 如果res.txt文件超过三小时没更新，则应该发邮件
# - 如果res.txt文件超过1G，则自动清理

import os,datetime
import smtplib
import time
from email.mime.text import MIMEText
from email.utils import formataddr
from email.mime.multipart import MIMEMultipart

def main(root_path):
    # 对img、html目录进行大小检查
    dir_names = ['img','html']
    for dir_name in dir_names:
        dir_path = f'{root_path}/{dir_name}'
        # 判断文件夹是否存在
        if os.path.exists(dir_path):
            # 文件夹大小超过1g，进行删除
            if size_over_one_G(dir_path):
                res = os.popen(f'rm -rf {dir_path}/*').read()
                print(res)
                log(f'{dir_path}内容超过1G，自动清理')
        # 新建文件夹
        else:
            os.mkdir(dir_path)

    # 对res.txt进行大小检查和日期检查
    file_name = 'res.txt'
    file_path = f'{root_path}/{file_name}'
    if os.path.exists(file_path):
        # 距离上次文件更新时间超过三个小时，发送邮件
        if file_date_over_three_hour(file_path):
            send_email()
            log('res.txt日志文件超过三小时未更新')
        if size_over_one_G(file_path):
            # 超过1G，清除之
            res = os.popen(f'rm -rf {file_path}').read()
            print(res)
            log('res.txt超过1G，自动清理')
    else:
        f = open(f'{file_path}','w')
        f.close()

# 当前运行机器的ip地址
def get_ip():
    r = os.popen(r"ip address |sed -rn '/state UP/{n;n;s#^ *inet (.*)/.*$#\1#gp}'").read().split('\n')
    return r[0]

# 指明ip，容器名，原因是容器res.txt超过三小时未更新
def send_email():
    sender = 'whr15266981370@163.com'
    receive = '819987540@qq.com'
    passwd = 'PJOTYCRDJDGVLBLQ' # 授权码python3
    mailserver = 'smtp.163.com'
    port = '465'
    local_ip = get_ip()
    subject = f'广告项目，ip：{local_ip}，容器：child，res.txt超过三个小时未更新'

    msg = MIMEMultipart('related')
    msg['From'] = formataddr(["广告项目", sender])
    msg['To'] = formataddr(["2190300211王浩然", receive])
    msg['Subject'] = subject

    txt = MIMEText('赶紧来修复吧！', 'plain', 'utf-8')
    msg.attach(txt)


    server = smtplib.SMTP_SSL(mailserver, port)
    server.login(sender, passwd)
    server.sendmail(sender, receive, msg.as_string())
    server.quit()

# 将发邮件这个动作记录到/root日志
def log(content):
    with open('/root/child.txt','a',encoding='utf8') as f:
        now_time = datetime.datetime.now().strftime(('%Y-%m-%d-%H-%M-%S'))
        f.write(f'{now_time}-监测到-child-{content}\n')

# 文件修改时间超过三小时
def file_date_over_three_hour(file_path):
    file_mtime = os.popen(f"ls -l --time-style '+%Y/%m/%d %H:%M:%S' {file_path}").read().split()[-3:-1]
    file_mtime = ' '.join(file_mtime)
    file_mtime = datetime.datetime.strptime(file_mtime,'%Y/%m/%d %H:%M:%S')

    now_time = datetime.datetime.now()

    gap_in_seconds = (now_time-file_mtime).seconds
    gap_in_days = (now_time-file_mtime).days

    # 超过一个小时或超过一天
    if gap_in_seconds > 3*60*60 or gap_in_days:
        return True
    else:
        return False

# 文件/文件夹内容超过1G
def size_over_one_G(path):
    res = os.popen(f'du -h --max-depth 1 {path}').read().split()[0]
    if res.endswith('G'):
        res = float(res.split('G')[0])
        if res > 1:
            # 文件夹大小超过1g，进行删除
            return True
    return False

if __name__ == '__main__':
    while 1:
        main('/home/child_no_log')
        time.sleep(12*60*60)
```



### 部署

将track_img_html_res_status.py放到/home/child_no_log/目录下

修改start_childr.sh：加上一个后台运行的python程序

```bash
cd /home/child_no_log
kill -9 $(lsof -t -i:8001)
nohup python3 -u main.py > res.txt &
nohup python3 -u track_img_html_res_status.py > log.txt &
```





## 利用supervisor保证发邮件的程序一直执行

### 测试

#### 安装

```bash
# 安装
apt update && apt -y install supervisor
# 配置文件
# 在/etc/supervisor目录下
root@3bc427bb99a2:/etc/supervisor# tree -L 2
.
|-- conf.d
`-- supervisord.conf

# 默认的配置文件为supervisord.conf
# 每行中用 ';',表示注释字符串
```



#### 配置

```bash
root@3bc427bb99a2:/etc/supervisor# cat supervisord.conf 
; supervisor config file

[unix_http_server]
file=/var/run/supervisor.sock   ; (the path to the socket file)
chmod=0700                       ; sockef file mode (default 0700)

[supervisord]
# 记录supervisord的运行日志
logfile=/etc/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)
pidfile=/etc/supervisor/supervisord.pid ; (supervisord pidfile;default supervisord.pid)
# 程序的日志文件
childlogdir=/etc/supervisor/log            ; ('AUTO' child log dir, default $TEMP)

; the below section must remain in the config file for RPC
; (supervisorctl/web interface) to work, additional interfaces may be
; added by defining them in separate rpcinterface: sections
[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL  for a unix socket

; The [include] section can just contain the "files" setting.  This
; setting can list multiple files (separated by whitespace or
; newlines).  It can also contain wildcards.  The filenames are
; interpreted as relative to this file.  Included files *cannot*
; include files themselves.

# 运行程序的配置文件
[include]
files = /etc/supervisor/conf.d/*.conf
```



```bash
# /root/test.sh
root@3bc427bb99a2:/etc/supervisor# cat /root/test.sh 
while true;do
	let n++
	echo $n >> /root/log.txt
done
root@3bc427bb99a2:/etc/supervisor/conf.d# cat test.conf 
[program:test]
command=/bin/bash /root/test.sh ; 程序启动命令
autostart=true       ; 在supervisord启动的时候也自动启动
startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒
autorestart=true     ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启
startretries=5       ; 启动失败自动重试次数，默认是3
user=root        ; 用哪个用户启动进程，默认是root
priority=999         ; 进程启动优先级，默认999，值小的优先启动
redirect_stderr=true ; 把stderr重定向到stdout，默认false
stdout_logfile_maxbytes=20MB  ; stdout 日志文件大小，默认50MB
stdout_logfile_backups = 20   ; stdout 日志文件备份数，默认是10
; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）
stdout_logfile=/root/test.log
stopasgroup=false     ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程
killasgroup=false     ;默认为false，向进程组发送kill信号，包括子进程
```



#### 运行测试

```bash
# 载入配置文件
supervisord -c /etc/supervisor/supervisord.conf
root@3bc427bb99a2:/etc/supervisor# supervisord -c /etc/supervisor/supervisord.conf

# /bin/bash /root/test.sh开始运行
root@3bc427bb99a2:/etc/supervisor# ll /root/
total 7120
-rw-r--r-- 1 root root 7262240 Sep 29 14:53 log.txt
-rw-r--r-- 1 root root       0 Sep 29 14:53 test.log
-rw-r--r-- 1 root root      55 Sep 29 14:43 test.sh
root@3bc427bb99a2:/etc/supervisor# ll /root/
total 8144
-rw-r--r-- 1 root root 8312464 Sep 29 14:53 log.txt
-rw-r--r-- 1 root root       0 Sep 29 14:53 test.log
-rw-r--r-- 1 root root      55 Sep 29 14:43 test.sh

# 查看运行状态的程序
root@3bc427bb99a2:/etc/supervisor# supervisorctl status
test                             RUNNING   pid 826, uptime 0:01:10
root@3bc427bb99a2:/etc/supervisor# supervisorctl status
test                             RUNNING   pid 826, uptime 0:01:18

# 日志文件
root@3bc427bb99a2:/etc/supervisor# cat supervisord.log
2021-09-29 14:53:30,180 CRIT Supervisor is running as root.  Privileges were not dropped because no user is specified in the config file.  If you intend to run as root, you can set user=root in the config file to avoid this message.
2021-09-29 14:53:30,180 INFO Included extra file "/etc/supervisor/conf.d/test.conf" during parsing
2021-09-29 14:53:30,183 INFO RPC interface 'supervisor' initialized
2021-09-29 14:53:30,183 CRIT Server 'unix_http_server' running without any HTTP authentication checking
2021-09-29 14:53:30,185 INFO daemonizing the supervisord process
2021-09-29 14:53:30,185 INFO supervisord started with pid 825
2021-09-29 14:53:31,188 INFO spawned: 'test' with pid 826
2021-09-29 14:53:41,199 INFO success: test entered RUNNING state, process has stayed up for > than 10 seconds (startsecs)

# 停止test项目
root@3bc427bb99a2:/etc/supervisor# supervisorctl stop test
test: stopped
root@3bc427bb99a2:/etc/supervisor# cat supervisord.log
2021-09-29 14:53:30,180 CRIT Supervisor is running as root.  Privileges were not dropped because no user is specified in the config file.  If you intend to run as root, you can set user=root in the config file to avoid this message.
2021-09-29 14:53:30,180 INFO Included extra file "/etc/supervisor/conf.d/test.conf" during parsing
2021-09-29 14:53:30,183 INFO RPC interface 'supervisor' initialized
2021-09-29 14:53:30,183 CRIT Server 'unix_http_server' running without any HTTP authentication checking
2021-09-29 14:53:30,185 INFO daemonizing the supervisord process
2021-09-29 14:53:30,185 INFO supervisord started with pid 825
2021-09-29 14:53:31,188 INFO spawned: 'test' with pid 826
2021-09-29 14:53:41,199 INFO success: test entered RUNNING state, process has stayed up for > than 10 seconds (startsecs)
2021-09-29 14:55:23,181 INFO waiting for test to stop
2021-09-29 14:55:23,186 INFO stopped: test (terminated by SIGTERM)

# 修改配置文件后重新加载配置文件
root@3bc427bb99a2:/etc/supervisor# supervisorctl reload
Restarted supervisord
root@3bc427bb99a2:/etc/supervisor# cat supervisord.pid 
825

# 测试supervisor是否能拉起来test.sh
root@3bc427bb99a2:/etc/supervisor# ll /root
total 154040
drwx------ 1 root root      4096 Sep 29 14:56 ./
drwxr-xr-x 1 root root      4096 Sep 29 14:36 ../
-rw-r--r-- 1 root root      3106 Dec  5  2019 .bashrc
-rw-r--r-- 1 root root       161 Dec  5  2019 .profile
-rw------- 1 root root      4390 Sep 29 14:56 .viminfo
-rw-r--r-- 1 root root 157700314 Sep 29 15:00 log.txt
-rw-r--r-- 1 root root         0 Sep 29 14:53 test.log
-rw-r--r-- 1 root root        55 Sep 29 14:43 test.sh
root@3bc427bb99a2:/etc/supervisor# ps -aux|grep bash
root           1  0.0  0.1   4232  3508 pts/0    Ss   14:36   0:00 /bin/bash
root         839 98.2  0.1   4204  3088 ?        R    14:56   4:09 /bin/bash /root/test.sh
root         849  0.0  0.0   3304   740 pts/0    S+   15:00   0:00 grep --color=auto bash
root@3bc427bb99a2:/etc/supervisor# kill -9 839
root@3bc427bb99a2:/etc/supervisor# ps -aux|grep bash
root           1  0.0  0.1   4232  3508 pts/0    Ss   14:36   0:00 /bin/bash
root         851  0.0  0.0   3304   672 pts/0    S+   15:00   0:00 grep --color=auto bash
root@3bc427bb99a2:/etc/supervisor# ps -aux|grep bash
root           1  0.0  0.1   4232  3524 pts/0    Ss   14:36   0:00 /bin/bash
root         852 84.8  0.1   4204  3172 ?        R    15:00   0:05 /bin/bash /root/test.sh
root         854  0.0  0.0   3304   736 pts/0    S+   15:00   0:00 grep --color=auto bash
root@3bc427bb99a2:/etc/supervisor# cat supervisord.log 
2021-09-29 14:56:12,416 CRIT Supervisor is running as root.  Privileges were not dropped because no user is specified in the config file.  If you intend to run as root, you can set user=root in the config file to avoid this message.
2021-09-29 14:56:12,416 INFO Included extra file "/etc/supervisor/conf.d/test.conf" during parsing
2021-09-29 14:56:12,416 INFO RPC interface 'supervisor' initialized
2021-09-29 14:56:12,416 CRIT Server 'unix_http_server' running without any HTTP authentication checking
2021-09-29 14:56:12,416 INFO supervisord started with pid 825
2021-09-29 14:56:13,419 INFO spawned: 'test' with pid 839
2021-09-29 14:56:23,429 INFO success: test entered RUNNING state, process has stayed up for > than 10 seconds (startsecs)
2021-09-29 15:00:36,690 INFO exited: test (terminated by SIGKILL; not expected)
2021-09-29 15:00:37,693 INFO spawned: 'test' with pid 852
2021-09-29 15:00:47,707 INFO success: test entered RUNNING state, process has stayed up for > than 10 seconds (startsecs)
```





### 配置文件的解释

```bash
[unix_http_server]
file=/tmp/supervisor.sock   ; UNIX socket 文件，supervisorctl 会使用
;chmod=0700                 ; socket 文件的 mode，默认是 0700
;chown=nobody:nogroup       ; socket 文件的 owner，格式： uid:gid

[supervisord]
logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log
logfile_maxbytes=50MB        ; 日志文件大小，超出会 rotate，默认 50MB
logfile_backups=10           ; 日志文件保留备份数量默认 10
loglevel=info                ; 日志级别，默认 info，其它: debug,warn,trace
pidfile=/tmp/supervisord.pid ; pid 文件
nodaemon=false               ; 是否在前台启动，默认是 false，即以 daemon 的方式启动
minfds=1024                  ; 可以打开的文件描述符的最小值，默认 1024
minprocs=200                 ; 可以打开的进程数的最小值，默认 200
  
; the below section must remain in the config file for RPC
; (supervisorctl/web interface) to work, additional interfaces may be
; added by defining them in separate rpcinterface: sections
[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface
  
[supervisorctl]
serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致
;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord
  
; 包含其他的配置文件
[include]
files = relative/directory/*.conf   ; 可以是 *.conf 或 *.ini

; [program:xx]是被管理的进程配置参数，xx是进程的名称
[program:xx]
command=/opt/apache-tomcat-8.0.35/bin/catalina.sh run  ; 程序启动命令
autostart=true       ; 在supervisord启动的时候也自动启动
startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒
autorestart=true     ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启
startretries=3       ; 启动失败自动重试次数，默认是3
user=tomcat          ; 用哪个用户启动进程，默认是root
priority=999         ; 进程启动优先级，默认999，值小的优先启动
redirect_stderr=true ; 把stderr重定向到stdout，默认false
stdout_logfile_maxbytes=20MB  ; stdout 日志文件大小，默认50MB
stdout_logfile_backups = 20   ; stdout 日志文件备份数，默认是10
; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）
stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.out
stopasgroup=false     ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程
killasgroup=false     ;默认为false，向进程组发送kill信号，包括子进程
```



### 控制命令

```bash
# 加载配置文件
supervisord -c /etc/supervisord/supervisord.fonc
# 如果报错：
# ps -aux|grep supervisord ，杀掉相应进程，重试

# 所有项目
supervisorctl status：查看所有项目进程的状态
supervisorctl reload: 重新启动配置中的所有程序

# 某个项目
supervisorctl stop es：停止es
supervisorctl start es：启动es
supervisorctl restart es: 重启es
supervisorctl update ：配置文件修改后可以使用该命令加载新的配置
```



### 保证邮件发送程序不挂掉

#### 容器外

```bash
# 安装supervisor，删除默认的配置文件
apt update && apt -y install supervisor && rm -rf /etc/supervisor

# 写好的配置文件分为child和main_control两个
# 55以外的机器上、容器外，只有child；55上有child和main

# 将写好的supervisor/移到/etc目录下
mv /supervisor /etc/

# 加载配置文件
supervisord -c /etc/supervisor/out_container.conf

# 查看运行状态
supervisorctl status
```





#### 容器内

```bash
# 安装supervisor
rm -rf /etc/supervisor
将写好的supervisor/移到/etc目录下
mv /supervisor /etc/

# 修改start_child.sh和start_main_control.sh
supervisord -c /etc/supervisor/in_container.conf

# 查看运行状态
supervisorctl status
```







### 问题

- supervisor不能管理后台进程，所以运行的command一方面不能转到后台运行，另一方面不能加守护进程（不过如果加了服务，也没必要用supervisor）

```bash
command中指定的进程已经起来，但supervisor还不断重启

     问题描述：command中启动方式为后台启动，导致识别不到pid，然后不断重启，本人使用的是elasticsearch，command                        指定的是$path/bin/elasticsearch -d，踩到的坑

     解决办法：supervisor无法检测后台启动进程的pid，而supervisor本身就是后台启动守护进程，因此不用担心这个

command = /usr/local/nginx/sbin/nginx 结果就一直启动nginx 因为这样的话 是后台运行的nginx，然而supervisor 不能管理后台运行进程，所以把nginx daemon off 守护关掉，就让他阻塞在前台bash运行，方便supervisor来管理。
应该是command = /usr/local/nginx/sbin/nginx -g 'daemon off'
```



# 口子哥部署

https://www.kouzige.cn/

## 字段

### 发现页

- 总页数

  - div class="pagination clearfix"
    - span /

- li class="item"

- 舆情基本属性

  - 发布时间
    - span class="item-meta-li date" 
      - 分钟前
      - 小时前
      - 天前
      - 日期，2021年8月16日
  - 阅读量
    - span class="item-meta-li views"
  - 点赞量
    - span class="item-meta-li likes"
  - url a href

```bash
{'release_time': '2021年08月31日', 'read_times': '34.8K', 'thumbs_up': '0', 'target_page_url': 'https://www.kouzige.cn/54919.html', 'img': 'iVBORw0KGgoAAAANSUhEUgAAAroAAACnCAYAAAD+Kv91AAAAAXNSR0IArs4c6QAAIABJREFUeJzsvVtsHFma3
```



### 详情页

- div class="entry"
- 舆情标题
  - h1 class="entry-title"
- 舆情内容
  - div class="entry-content clearfix"
- 口子名称
  - p 口子名称：
- 申请入口
  - a rel="noopener noreferrer nofollow"
    - 可能是链接，可能是微信小程序的二维码
      - 如果是链接，存链接
      - 如果不是链接，存文本（指示信息）



### 目标页

- 目标页标题
  - title
- 目标页快照
  - 截图，base64
- 目标页链接
  - 跳转后的链接



```bash
# 给集群的发现页任务
	url:str
	tag:0,int
	release_city:str
# 从集群收到的发现页数据（为空，设置为None）
	html:str
	img:str
	
	# fake_url:str
	# real_url:str
	
	div_pos:list([[1,2,3,4],[]])
	tag:0,int
	release_city:str
	# time:2021-09-03
# 发给集群的目标页任务
	url:str(通过html解析出的跳转之前的url)
	tag:1,int
	release_city:str
# 从集群收到的目标页数据
	html:str
	img:str
	
	fake_url:str，之前传给集群的url
	real_url:str，跳转之后的url
	
	# div_pos:list([[1,2,3,4],[]])
	tag:1,int
	release_city:str
	time:2021-09-03
# 存入数据库的发现页
	title:str
	description:str
	release_company:str
	release_city:str
	tags:[str,str...]
	img:str(base64)
# 存入数据库的目标页
	title:str
	types:str
	manager_name:str
	company_location:str
	service_description:str
	release_city:str
	img:str
```





ip：172.16.2.55:8005

启动redis

```bash
docker pull redis:6.2.4-buster

docker run -itd --name kouzige_redis -p 6379:6379 redis:6.2.4-buster /bin/bash
cd 
# 修改后台运行
redis-server ./redis.conf
# 进行访问测试
```





start_kouzige_create_docker.sh 占用8005端口

```bash
kill -9 $(lsof -t -i:8005)
cd /home/kouzige/
nohup python3 -u create_init_url.py > res.txt &
```



start_kouzige_child_docker.sh

```bash
cd /home/kouzige/
nohup python3 -u child_main.py > res.txt &
```



启动create模块

```bash
docker stop kouzige_create
docker rm kouzige_create
docker run -itd --name  kouzige_create -v /root:/root -p 8005:8005 172.16.2.40:5000/kouzige:1.0 /bin/bash
docker exec -it kouzige_create /bin/bash /start_kouzige_create_docker.sh
```



启动child模块

```bash
docker stop kouzige_child
docker rm kouzige_child
docker run -itd --name  kouzige_child -v /root:/root 172.16.2.40:5000/kouzige:1.0 /bin/bash
docker exec -it kouzige_create /bin/bash /start_kouzige_child_docker.sh
```





```bash
docker stop kouzige_create
docker rm kouzige_create
docker run -itd --name  kouzige_create -v /root:/root -p 8005:8005 172.16.2.40:5000/kouzige:1.0 /bin/bash

docker exec -it kouzige mkdir /home/kouzige
docker cp /kou_zi_ge.py kouzige:/home/kouzige/
docker cp /upload_kouzige.py kouzige:/home/kouzige/
docker cp /requirements.txt kouzige:/home/kouzige/
docker attach kouzige
cd /home/kouzige
pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple
nohup python3 -u kou_zi_ge.py > res.txt &
```





# redis

## 安装

见系统镜像一节，注意设置软连接，方便访问，并设置守护进程，让服务器端后台运行。



## 连接

```python
# 导入库 
import redis
# 连接redis数据库
r = redis.StrictRedis(host='localhost',port=6379.db=0,decode_response=True)
# host是一个字符串，可以连本地的，也可以连远程的。（后面测试下win连服务器的）
# 端口号在服务器端的配置文件中
# db默认16个
# 默认decode_responses为False，返回utf-8编码后的字符串

—————————测试———————————
import redis
r = redis.StrictRedis(host='localhost',port=6379,db=0)#,decode_responses=True)
r.set('key','你好')
a = r.get('key')
print(type(a))
print(a)
print(a.decode('utf8'))
<class 'bytes'>
b'\xe4\xbd\xa0\xe5\xa5\xbd'
你好

# 如果key存在，返回其value（str）
# 对于不存在的key，返回 <class 'NoneType'>
# 所以判断应该用类型，看是不是str

—————————测试———————————
import redis
r = redis.StrictRedis(host='localhost',port=6379,db=0,decode_responses=True)
r.set('key',1)
a = r.get('ke')
if type(a) is str:
    print(a)
else:
    print('not')

b = r.get('key')
if type(b) is str:
    print(b)
else:
    print('not')
    
not
1
```



## 获取所有的key

r.keys()返回所有的key的名称，类型为列表。

可以用一个正则表达式进行匹配。

```python
import redis
r = redis.StrictRedis(host='localhost',port=6379,db=0,decode_responses=True)
keys = r.keys()
print(keys)
['key', 'hmp']
```



## 删除所有的key

r.delete(key_name/names)





python操作redis

如果没有某个key，返回 `<class 'NoneType'>`。否则，在设置了



# selenium截图时中文出现乱码

 链接: [https://pan.baidu.com/s/1kqXoMo-mwhtgAn6_dXJQcg](https://links.jianshu.com/go?to=https%3A%2F%2Fpan.baidu.com%2Fs%2F1kqXoMo-mwhtgAn6_dXJQcg)  密码: a5c9

```bash
mkdir -p /usr/share/fonts/chinese/        #创建中文字体目录
cp songti.ttf /usr/share/fonts/chinese/     #将字体文件拷贝到/usr/share/fonts/chinese/中
cd /usr/share/fonts/chinese/
fc-cache -fv                              #为刚加入的字体设置缓存使之有效
fc-list                                   #查看系统中的字体
```

lrange find_page_url_queue 0 100

lrange target_page_url_queue 0 100

lrange final_page_url_queue 0 100

llen find_page_url_queue

llen target_page_url_queue

llen final_page_url_queue



构造find_page_url的模块单独拿出来，串行响应请求。



# 对存储图片、html、日志的处理

裁剪时，图片先保存在本地，然后裁剪

- 现在裁剪后，应该马上把图片删除。

对于html，一开始是做测试debug用。

- 现在直接不存了

对于日志文件，记录内容不变（看看有没有多存的，比如打印图片，太占用空间了）

- 现在改为七天清空一次日志文件

log模块，只记录没有成功删除的情况



du -h --max-depth=1



# docker启动时端口映射错误

重启docker服务，然后重启某个容器

```bash
systemctl restart docker
docker restart child main_control
```



# 日志记录

```bash
# 首先在调用logging模块时，需要配置一下日志记录的格式、日志文件的位子，所以建议在入口函数里面配置logging模块

```



# 测试最终版

- 将镜像版本升级为6.0
  - 需要将启动容器的脚本进行修改，然后发布到所有机器上
- 将55：main_control的cluser端口临时改为8080
- 在54上关闭之前的child，部署一个child（6.0）





# 编译过程

[(9条消息) gcc编译工具常用命令以及汇编语言_MSY的博客-CSDN博客_gcc编译命令](https://blog.csdn.net/qq_44644740/article/details/109086520)



# python文件/文件夹



## 判断是文件还是文件夹

os.path.isfile(path)，如果path存在且是文件，返回True；不存在或存在但为文件夹返回False。

![image-20210927222224676](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927222224676.png)



os.path.isdir(path)

存在且为文件夹，返回True；不存在或存在但为文件，返回False。

![image-20210927224233847](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927224233847.png)







## 文件



### 存在判断

os.path.exists(path)，可以用来判断文件或文件夹是否存在。

不区分文件或文件夹。

![image-20210927222358123](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927222358123.png)





### 创建

open

![image-20210927224029986](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927224029986.png)





### 删除

os.remove(path)

文件存在

![image-20210927223454207](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927223454207.png)



文件不存在

![image-20210927223956560](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927223956560.png)



### 文件的扩展名

os.path.splitext(file_name)，返回一个元组，（文件名，文件的扩展名）

![image-20210928160758260](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210928160758260.png)









## 文件夹

### 存在判断

os.path.exists(path)



### 创建一个目录

![image-20210927225200127](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927225200127.png)



如果和文件夹命名冲突，报错

![image-20210927225218669](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927225218669.png)



如果和文件的命名冲突，报错（os维护的索引表，不允许同一目录下即同一索引表下命名相同）

![image-20210927225427019](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927225427019.png)



### 递归创建多级目录

os.makedirs()

![image-20210928163107584](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210928163107584.png)





### 删除

文件夹存在

![image-20210927224838222](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927224838222.png)



![image-20210927224901477](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927224901477.png)



文件夹非空

![image-20210927225619468](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927225619468.png)



文件夹不存在

![image-20210927225636450](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927225636450.png)



### 当前工作目录

os.getcwd()，返回python脚本所在的目录。如果有函数调用，返回调用函数所在目录，即项目的根目录。



单独执行函数

![image-20210927223211883](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927223211883.png)



函数调用

![image-20210927223234386](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210927223234386.png)

## 路径

### 是否是绝对路径

os.path.isabs()。若路径为绝对路径，返回True。

判断的只是形式，如果路径不存在但为绝对路径，仍然返回True。

![image-20210928160228252](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210928160228252.png)









## 总结

| 功能                | 文件/文件夹 | 函数                        | 说明                                                         |
| ------------------- | ----------- | --------------------------- | ------------------------------------------------------------ |
| 当前脚本的工作目录  |             | os.getcwd()                 | 如果有函数调用，返回的是调用函数所在文件所在的目录           |
|                     |             |                             |                                                              |
| 文件/文件夹是否存在 | 文件/文件夹 | os.path.exists(path)        | 如果存在返回True，否则返回False                              |
| 重命名              |             | os.rename(old,new)          | 如果没有old这个文件/文件夹，报错：FileNotFoundError；如果有并且new合法，修改文件名 |
|                     |             |                             |                                                              |
| 是不是文件          | 文件        | os.path.isfile(path)        | 是文件，返回True；如果该文件不存在或文件存在但为文件夹，返回False |
| 删除文件            |             | os.remove(path)             | 没有返回值；如果该文件不存在，报错，FileNotFoundError        |
| 创建文件            |             | open                        | 记得关闭文件                                                 |
| 获得文件的扩展名    |             | os.path.splitext(file_name) | 返回一个元组，第一个值是文件名，第二个值是后缀               |
|                     |             |                             |                                                              |
| 是不是文件夹        | 文件夹      | os.path.isdir(path)         | 是文件夹，返回True；如果该文件不存在或文件存在但为文件，返回False |
| 创建单个目录        |             | os.mkdir(path)              | 没有返回值。如果创建文件夹的命名和文件、文件夹命名冲突，报错：FileExistsError |
| 递归创建多级目录    |             | os.makedirs()               | 没有返回值，相当于linux的mkdir -p                            |
| 删除目录            |             | os.rmdir(path)              | 1、若文件夹非空，报错：OSError  2、若文件夹不存在，报错：FileNotFoundError   3、若删除的是文件，报错：NotADirectoryError |
|                     |             |                             |                                                              |
| 是否是绝对路径      |             | os.path.isabs()             | 只是形式上的判断。不考虑路径是否真的存在                     |
|                     |             |                             |                                                              |
|                     |             |                             |                                                              |
|                     |             |                             |                                                              |
|                     |             |                             |                                                              |
|                     |             |                             |                                                              |



# docker exex

主要用来执行容器内的脚本，这样就不用进入容器，方便在容器外写脚本，快速运维。

```bash
docker exex -d 在后台运行（最常用） container_name command arguments
		   -it 以交互模式运行
# 在容器内
root@3bc427bb99a2:~# pwd
/root
root@3bc427bb99a2:~# cat 1.sh 
echo 'heello' >> /root/1.txt

# 容器外执行
root@whr:~# docker exec -d test /bin/bash /root/1.sh

# 容器内的结果
root@3bc427bb99a2:~# ls
1.sh  1.txt  test.log  test.sh
root@3bc427bb99a2:~# cat 1.txt 
heello
```

# python logging模块

首先要对logging模块登记的信息进行配置。

```python
```





# python导入自己的模块

## 调用函数和模块在同一文件夹下

![image-20210928164107484](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210928164107484.png)



## 调用函数和模块所在文件夹在同一文件夹下

![image-20210928164516743](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210928164516743.png)



## 调用函数和模块在同级目录

### pycharm运行

![image-20210928164713607](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210928164713607.png)

这个项目时再pycharm中创建的，pycharm会以项目目录为根目录进行寻找。

如果将这个项目移动到linux平台呢？



### linux运行pycharm项目

```bash
root@whr:/home/test# tree
.
├── enter
│   └── call.py
└── func
    ├── __pycache__
    │   └── __init__.cpython-36.pyc
    └── test
        ├── called.py
        └── __pycache__
            └── called.cpython-36.pyc
root@whr:/home/test/enter# python3 call.py 
Traceback (most recent call last):
  File "call.py", line 1, in <module>
    from func.test import called
ModuleNotFoundError: No module named 'func'
```

还是运行不了。

移动一下文件位置。

```bash
root@whr:/home/test# tree 
.
├── call.py
├── enter
└── func
    ├── __pycache__
    │   └── __init__.cpython-36.pyc
    └── test
        ├── called.py
        └── __pycache__
            └── called.cpython-36.pyc

5 directories, 4 files
root@whr:/home/test# python3 call.py 
hello world
```



### 非pycharm项目

如果不是在pycharm中新建的项目。

```bash
D:\pythoncode\trash>tree
卷 新加卷 的文件夹 PATH 列表
卷序列号为 F097-B144
D:.
├─enter
└─func
    └─test

D:\pythoncode\trash>cd enter

D:\pythoncode\trash\enter>python call.py
Traceback (most recent call last):
  File "call.py", line 1, in <module>
    from func.test import called
ModuleNotFoundError: No module named 'func'
```

会提示找不到func这个文件夹

`包就是一个至少包含__init__.py文件的文件夹，这个文件是必须存在的，否则，Python就把这个目录当成普通目录(文件夹)，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是对应包的名字。调用包就是执行包下的__init__.py文件。`

要让自己的文件夹被python解释器找到，有两个条件：

- 文件夹是包，即目录下有`__init__.py` 文件，不管内容是什么（导入包时，首先执行`__init__.py文件`)。
- 将项目路径告诉python

比如：bs4

![image-20210928183908837](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210928183908837.png)



![image-20210928183910773](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210928183910773.png)



这样进行修改。在包的目录中都加入init文件，将项目目录放到path下。

![image-20210928185014574](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210928185014574.png)



![image-20210928185034525](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210928185034525.png)

call.py

```python
import sys
sys.path.append(r'D:\pythoncode\trash')

from func.test import called
called.func()
```

将项目目录告诉python解释器。



在func目录下有init文件

![image-20210928185140749](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210928185140749.png)

`__init__.py`

```python
if __name__ == '__main__':
    print('func作为入口函数运行')
else:
    print('func作为包运行')
```



在func目录下有init文件

![image-20210928185210580](https://raw.githubusercontent.com/whr819987540/pic/main/image-20210928185210580.png)

`__init__.py`

```python
if __name__ == '__main__':
    print('func.test作为入口函数运行')
else:
    print('func.test作为包运行')
```



在cmd下运行

```bash
D:\pythoncode\trash\enter>python call.py
func作为包运行
func.test作为包运行
hello world
```



在linux下运行（将项目目录改一下）

```bash
root@whr:/home/test/enter# python3 call.py 
func作为包运行
func.test作为包运行
hello world
```



#### 核心问题

- 告诉python解释器去哪儿找
  - sys.path.append(项目目录)
- 将目录制作成包
  - 加上`__init__.py`文件





# ls结果转datetime

```bash
ls -l --time-style '+%Y-%m-%d-%H-%M-%S'
nslab@nslab:~$ ls -l --time-style '+%Y-%m-%d-%H-%M-%S'
total 96
-rw-r--r--  1 nslab            nslab 11584 2021-09-03-19-54-08 cluster_control.py
-rw-rw-r--  1 nslab            nslab    72 2021-08-03-05-39-28 ctc.txt
drwxrwxr-x  4 systemd-coredump nslab  4096 2021-08-09-20-31-06 data
```



```python
import datetime,os
mtimes = os.popen("ls -l --time-style '+%Y-%m-%d-%H-%M-%S'").read().strip().split('\n')[1:]
mtimes = [ i.split()[-2] for i in mtimes]
for mtime in mtimes:
    mtime_datetime = datetime.datetime.strptime(mtime,'%Y-%m-%d-%H-%M-%S')
    print(mtime_datetime)
    print(mtime_datetime.strftime('%Y-%m-%d'))
```





mogodb，redis

后来先服务。目标页和发现页交替进行。



数据介绍。

关键词的丰富，如何丰富关键词？



任务调度相关文章

发专利。

数据（mysql，图片）pull回学校。

图片pull到本地。

统计数据：以一台公网机器为中转，回传统计数据到学校。

看文章（英文论文）





# numpy

## numpy.array比较是否相同

- (array_1==array_2)

```python
>>> a = np.array([1,2,3])
>>> b = np.array([1,2,3])
>>> c = np.array([1,2,4])
>>> a == b
array([ True,  True,  True])
>>> a == c
array([ True,  True, False])
```

- (array_1 == array_2).all()

只有当array_1和array_2所有元素都对应相等时才返回一个True，否则返回False

```python
>>> a = np.array([1,2,3])
>>> b = np.array([1,2,3])
>>> c = np.array([1,2,4])
>>> (a == b).all()
True
>>> (a == c).all()
False
```

- (array_1 == array_2).any()

当array_1和array_2中存在一个元素对应相等时就返回一个True

只有当所有对应元素都不相等时，才返回False

```python
>>> a = np.array([1,2,3])
>>> b = np.array([1,2,3])
>>> c = np.array([1,2,4])
>>> (a == b).any()
True
>>> (a == c).any()
True

```

